해당 주차에는 모의 면접이 진행되어, 모의 면접에 참여하지 않는 경우 CS 공부를 하고 기록을 남기기로 했습니다.

저는 지난주에 정리해 두었던 모의 면접 질문 리스트를 바탕으로 간단한 답변을 준비해 보았습니다.

---

### 1. 메모리와 가상 메모리의 차이점에 대해 설명해 주세요.

메모리는 CPU가 직접 접근할 수 있는 물리적 메모리(RAM)를 의미하고, 
가상 메모리는 실제 메모리보다 더 큰 주소 공간을 제공하기 위해 디스크 공간 일부를 메모리처럼 사용하는 기술입니다.

운영체제는 가상 메모리를 통해 각 프로세스에 독립된 메모리 공간을 제공해 보안성과 안정성을 높이고, 
메모리가 부족할 경우 잘 사용되지 않는 데이터를 디스크로 보내 메모리를 효율적으로 관리합니다.

메모리는 실제 하드웨어, 가상 메모리는 운영체제가 만들어낸 논리적 공간이라고 할 수 있습니다.

### 2. CPU의 기본 동작 원리에 대해 설명해 주세요.

CPU는 명령어 사이클(fetch-decode-execute)을 반복하면서 동작합니다.
	1.	Fetch: 메모리에서 명령어를 가져오고,
	2.	Decode: 명령어를 해석해 어떤 연산을 할지 결정하고,
	3.	Execute: 실제 연산을 수행하거나 데이터를 메모리로 읽고 씁니다.

이 과정은 제어장치, 연산장치(ALU), 레지스터 같은 구성 요소가 협력해 처리합니다. 
제어장치는 흐름을 관리하고, ALU는 연산을, 레지스터는 데이터를 임시 저장합니다. 
CPU는 명령어를 가져와 해석하고 실행하는 반복적인 구조로 프로그램을 처리합니다.

### 3. CPU 코어 수와 스레드 수 사이의 관계는 무엇인가요?

CPU의 코어 수는 동시에 처리할 수 있는 물리적인 작업 단위이고, 
스레드 수는 그 코어가 동시에 처리할 수 있는 논리적인 작업 단위입니다.

보통 하나의 코어는 기본적으로 하나의 스레드를 처리하지만, 
하이퍼스레딩 같은 기술을 통해 하나의 코어가 두 개의 스레드를 처리할 수도 있습니다. 
예를 들어, 4코어 8스레드 CPU는 4개의 물리 코어에 각 코어당 2개의 스레드가 할당된 구조입니다.

요약하면, 코어는 물리적, 스레드는 논리적 작업 단위이고, 스레드 수는 코어 수 이상이 될 수 있습니다.

### 4. 캐시 메모리가 무엇이며, 캐시 친화적인 프로그램을 작성하기 위해 어떤 점을 고려해야 하나요?

캐시 메모리는 CPU와 메인 메모리 사이에 위치한 고속 임시 저장소로, 
자주 사용하는 데이터를 저장해 CPU 접근 속도를 높이는 역할을 합니다.

캐시는 지역성(Locality) 원칙을 기반으로 작동합니다.

- 시간 지역성: 최근 접근한 데이터에 다시 접근할 가능성이 높고,
- 공간 지역성: 인접한 메모리 주소에 접근할 가능성이 높습니다.

그렇기 때문에 캐시 친화적인 프로그램을 작성하려면,
- 데이터 접근 패턴을 연속적이고 규칙적으로 만들고,
- 데이터 구조를 작게 유지해 캐시 적중률을 높이는 게 중요합니다.

예를 들어 배열을 순차적으로 접근하는 것이 캐시 친화적이고, 랜덤한 메모리 접근은 캐시 효율을 떨어뜨립니다.

### 5. 콜백 함수와 비동기 함수의 차이를 설명해주세요.

콜백 함수는 어떤 작업이 끝난 후 호출되도록 등록된 함수입니다. 주로 비동기 작업의 완료 시점을 알려주기 위해 사용됩니다.

비동기 함수는 작업을 바로 끝내지 않고, 결과가 준비되면 나중에 알려주는 함수입니다. 
이때 완료된 후 호출할 함수로 콜백을 넘기기도 합니다.

정리하면,
- 콜백 함수는 결과를 처리하는 방법이고,
- 비동기 함수는 결과가 준비될 때까지 기다리지 않고 바로 다음 작업을 진행하게 합니다.

비동기 함수 안에서 콜백을 사용해 결과 처리를 위임하는 게 일반적입니다.

### 6. 동기와 비동기의 차이를 설명하고, 각 경우에서의 장단점을 말해 주세요.

동기(Synchronous)는 작업이 끝날 때까지 다음 작업이 대기하는 방식이고, 
비동기(Asynchronous)는 작업이 끝날 때까지 대기하지 않고 다른 작업을 먼저 수행할 수 있는 방식입니다.

- 동기 장점: 흐름이 단순해서 코드가 이해하기 쉽고 디버깅이 용이합니다.
- 동기 단점: 작업 지연이 전체 지연으로 이어져, 응답성이 떨어질 수 있습니다.
- 비동기 장점: 대기 시간 동안 다른 작업을 처리할 수 있어 효율적이고, 시스템 자원을 더 잘 활용할 수 있습니다.
- 비동기 단점: 복잡한 흐름 관리가 필요하고, 디버깅이 어렵습니다.

동기는 단순하지만 느릴 수 있고, 비동기는 복잡하지만 효율적입니다.

### 7. 컴파일러는 어떻게 작동하나요? 컴파일러의 주요 단계와 각 단계에서 발생하는 변환 과정을 설명하세요.

컴파일러는 소스 코드를 기계어로 변환하는 프로그램입니다. 주요 단계는 다음과 같습니다.
1.	어휘 분석(Lexical Analysis): 소스 코드를 토큰 단위로 분리합니다. 예를 들어 키워드, 식별자, 연산자 같은 단위로 나눕니다.
2.	구문 분석(Syntax Analysis): 토큰을 분석해 문법 구조(구문 트리, 파스 트리)를 만듭니다. 문법 오류를 잡아내는 단계입니다.
3.	의미 분석(Semantic Analysis): 타입 검사나 선언 확인처럼 코드 의미를 검증합니다.
4.	중간 코드 생성(Intermediate Code Generation): 플랫폼 독립적인 중간 코드를 생성합니다. (예: IR, 바이트코드)
5.	최적화(Optimization): 코드의 성능을 개선합니다. (예: 불필요한 연산 제거)
6.	코드 생성(Code Generation): 중간 코드를 타겟 기계어로 변환합니다.
7.	코드 최적화(Code Optimization): 최종 기계어 코드를 최적화해 실행 효율을 높입니다.

요약하면, 컴파일러는 분석 → 변환 → 최적화 → 생성의 흐름으로 작동합니다.

### 8. 링커는 어떤 역할을 하나요? 링커가 하는 일과 컴파일 과정에서 발생할 수 있는 링커 에러에 대해 설명해 주세요.

링커(Linker)는 컴파일된 여러 오브젝트 파일(.o)을 하나의 실행 파일로 연결하는 역할을 합니다.

링커의 주요 작업은 다음과 같습니다.
- 심볼 결합: 함수나 변수를 정의한 파일과 사용하는 파일을 연결합니다.
- 주소 배정: 각 코드와 데이터에 메모리 주소를 할당합니다.
- 라이브러리 연결: 표준 라이브러리나 외부 라이브러리와 프로그램을 결합합니다.

링커 에러는 보통 다음 상황에서 발생합니다.
- 정의되지 않은 심볼: 선언만 있고 구현이 없는 함수나 변수 사용
- 중복 정의: 같은 심볼이 여러 오브젝트 파일에서 정의될 때
- 라이브러리 누락: 필요한 라이브러리가 링크되지 않았을 때

링커는 컴파일된 조각들을 연결해 하나의 완성된 프로그램을 만드는 역할을 하며, 정의/참조 오류가 있을 때 링커 에러가 발생합니다.