# 입출력 시스템의 이해와 최적화

## 6.3 파일을 읽을 때 프로그램에는 어떤 일이 발생할까?

### 메모리 관점에서의 입출력
입출력은 본질적으로 메모리 복사(copy) 작업입니다:
- 입력(Input): 외부 장치 → 메모리로의 데이터 복사
- 출력(Output): 메모리 → 외부 장치로의 데이터 복사

### 파일의 본질
- 모든 입출력 장치는 파일이라는 개념으로 추상화됩니다
- 파일은 N 바이트의 연속된 수열로 이해할 수 있습니다
- 디스크, 네트워크, 터미널, 파이프 등이 모두 파일로 취급됩니다

## 6.4 높은 동시성의 비율: 입출력 다중화

### 파일 서술자(File Descriptor)
- 파일을 열 때 커널이 반환하는 식별자입니다
- 모든 파일 작업은 이 식별자를 통해 수행됩니다
- 소켓 통신에서도 3-way handshake 성공 후 파일 서술자를 얻어 통신합니다

### 입출력 처리 과정
1. 운영체제는 I/O 진행 중 프로세스 실행을 일시 중지
2. 입출력 블로킹 대기열에 프로세스를 배치
3. 작업 완료 시 준비완료 대기열로 이동
4. 데이터는 운영체제 내부 버퍼를 거쳐 프로세스 주소 공간으로 복사

### Zero-Copy 기술
- 전통적인 방식: 디스크 → 커널 버퍼 → 사용자 버퍼 → 커널 버퍼 → 네트워크
- Zero-Copy 방식: 디스크 → 커널 버퍼 → 네트워크
- 운영체제를 우회하는 것이 아닌, 사용자 버퍼를 거치지 않는 방식입니다


### 입출력 다중화의 필요성
- 블로킹 입출력은 동시성 처리가 어렵습니다
- 멀티스레딩은 스레드 수 증가와 스케줄링 부담이 있습니다
- 해결책: 커널이 응용프로그램에 이벤트를 통지하는 방식

### 리눅스의 입출력 다중화 기술

#### select
- fd_set으로 감시할 파일 서술자를 묶어 전달
- 커널이 전체 fd를 순회하며 준비 상태 확인
- 매번 fd_set을 재설정해야 하는 단점

#### poll
- pollfd 구조체로 감시할 파일 서술자 관리
- select보다 최적화되어 있으나 여전히 순차 검색
- 한 번에 더 많은 파일 서술자 감시 가능

#### epoll
- 커널 내부에 이벤트 감시용 객체(epfd) 생성
- 준비된 파일 서술자를 ready 큐에서 관리
- 가장 효율적인 동시성 처리 가능


## 6.5 mmap: 메모리 읽기와 쓰기 방식으로 파일 처리하기

### mmap의 개념
- 파일을 프로세스의 가상 메모리 주소 공간에 매핑
- 메모리 배열처럼 파일에 접근 가능
- 페이지 폴트 발생 시 필요한 부분만 디스크에서 로드

### mmap vs 전통적인 입출력
장점:
- 시스템 호출과 데이터 복사 부담 감소
- 대용량 파일 처리에 유리
- 메모리 접근 방식으로 파일 조작 가능

단점:
- 페이지 폴트 발생 가능성
- 메모리 매핑 유지를 위한 추가 데이터 구조 필요


## 6.6 컴퓨터 시스템의 각 부분에서 얼마큼 지연이 일어날까?

### 디스크 접근 최적화
- 순차 읽기는 상대적으로 빠름
- 임의 접근은 디스크 회전으로 인한 지연 발생
- 많은 DB가 append-only 방식 채택

### 성능 최적화 팁
1. 적절한 입출력 다중화 기술 선택 (epoll 권장)
2. Zero-copy 기술 활용
3. 대용량 파일은 mmap 고려
4. 순차 접근이 가능한 경우 최대한 활용

