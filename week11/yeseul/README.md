## 6.3 파일을 읽을 때 프로그램에는 어떤 일이 발생할까?

### 6.3.1 메모리 관점에서 입출력

메모리 관점에서 입출력은 단순히 복사(copy)의 일이다. 외부 장치에서 메모리로 복사되면 입력이고, 메모리에서 외부 장치로 복사되면 출력인 것이다.

## 6.4 높은 동시성의 비결: 입출력 다중화

파일은 N 바이트의 수열로 이해하면 편하다. 또한 모든 입출력 장치는 파일이라는 개념으로 추상화 된다.

### 6.4.1 파일 서술자

read 함수를 사용해서 파일 내용을 읽을 때는 `read(buffer)`의 코드를 사용한다. 그렇다면 어디에서 데이터를 읽어 오는 것일까?

이 때, 번호표를 뽑는데 파일 서술자를 이용해 번호를 받는다.

### 6.4.2 다중 입출력을 어떻게 효율적으로 처리할까?

파일 서술자는 3 way handshake에 성공하면 accept 함수를 호출하여 연결을 얻어 통신을 진행할 수 있다.

read 함수는 일반적으로 블로킹 입출력이다. 그렇기 때문에 높은 동시성을 발휘할 수 없다.

### 6.4.3 상대방이 아닌 내가 전화하게 만들기

커널에 계속 전화를 거는 대신 필요할 때 커널이 응용 프로그램에 통지하도록 하자.

### 6.4.4 입출력 다중화

하나의 채널에서 여러 신호를 전송할 수 있어야 하므로 여러 신호를 하나로 합칠 필요가 있는데, 이 일을 하는 장치를 다중화기라고 한다.

리눅스 세계에서 입출력 다중화 기술을 사용하는 방법에는 select, poll, epoll 세 가지가 있다.

### 6.4.5 select, poll, epoll

select는 파일 서술자가 준비 완료 상태인지 알려면 처음부터 끝까지 다시 확인 해야한다. 그래서 대량의 파일 서술자를 감지한다면 효율이 매우 떨어진다.

poll과 select는 매우 유사하지만 poll이 select에 비해 최적화 되어있다.(단지 한 번에 감시 가능한 파일 서술자 수가 더 많아질 뿐이다.)

epoll은 커널에 필요한 데이터 구조를 생성하여 준비 완료된 파일 서술자 목록을 관리한다. 그래서 기본적으로 높은 동시성 처리가 가능하다.

## 6.5 또 다른 고급 입출력 기술: nmap

nmap을 사용하면 메모리 읽기와 쓰기 방식으로 파일을 처리 가능하다.

nmap으로 디스크의 파일을 읽고 쓸 때는 시스템 호출과 데이터 복사가 주는 부담이 없기 때문에 큰 부담이 없다. 그러나 프로세스 주소 공관과 파일의 사상 관계를 유지하기 위해 특정 데이터 구조를 사용해야하고 페이지 누락 문제가 있기에 nmap이 성능 면에서 항상 read/write 함수보다 더 낫다고 할 수는 없다.

nmap은 메모리를 직접 읽고 쓰는 것처럼 디스크의 파일을 사용할 수 있어 매우 편리하다. 특히 물리 메모리 용량을 초과할 정도의 큰 파일을 다룰 때, 전통적인 방법이라면 파일을 조금씩 나눠 메모리에 적재 해야 하지만, nmap은 아무 문제가 없을 것이다.
