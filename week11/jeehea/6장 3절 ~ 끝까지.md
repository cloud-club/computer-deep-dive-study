# 6장 3절 ~ 끝


## 궁금
- 동기 입출력 다중화에 대한 설명 - 누가 알림받고 누가 처리하고 누가 깨어나는 거지? 예시 더 찾아보기..
- 466p
    저수준 계층의 시스템 호출을 사용하여 커널상태와 사용자 상태간 데이터 복사해야함
    이 번거로운 작업이 mmap 에서는 없음 
    → 왜죠? 결국엔 CPU가 읽으려면 메모리에 적재해야하는 거 아닌가요
  디스크에서 왔다갔다 한다는 건가요?? 속도차이는 어떻게 해결..?


## 정리
### 입출력 처리 과정

- 메모리 관점에서의 입출력 : 메모리와 외부 장치 사이의 데이터 복사일 뿐
- read() 등의 함수 호출로 파일을 읽을 때
    1. 프로세스A가 입출력 필요
    2. 해당 프로세스(스레드)는 입출력 buffer 주소와 함께 입출력을 요청한 후 블로킹되고, 블로킹 대기열에 들어감
    3. 운영체제는 DMA에게 buffer 메모리 영역으로 데이터 복사 요청
    4. CPU는 블로킹으로 실행 중지된 프로세스A 대신 준비완료 대기열에 있던 프로세스B를 실행
    5. 3번의 데이터 복사작업이 완료되면 디스크가 CPU에게 인터럽트
    6. 인터럽트 처리를 통해 프로세스 A가 준비완료 대기열로 이동
    7. CPU는 우선순위에 따라 프로세스A를 실행하거나 프로세스B를 마저 실행한 후 프로세스A를 실행함
    8. 프로세스A의 실행이 재개됨. 프로세스A의 실행에 필요한 데이터가 buffer에 채워져 있음
- 무복사 : 이 과정에서 데이터 복사는 디스크 → 운영체제 → 메모리를 거치게 되는데,
    
    운영체제를 건너뛰는 방식을 무복사zero-copy 라 함
    

### 입출력 다중화 출현 배경

- 모든 입출력 장치는 파일로 볼 수 있으며, 모든 입출력은 파일의 읽고쓰기로 볼 수 있음
- 파일 서술자 : 입출력 시 프로세스와 커널이 주고받는 파일 식별 번호. 커널이 파일을 열면 반환해주며 이 번호를 통해 파일의 모든 정보를 알 수 있음
- e.g. 소켓 통신에서의 입출력 : 3 way handshake 를 성공하면 파일서술자를 얻음. 이를 통해 통신 처리.
    
    → 수많은 통신을 처리해야함. 블로킹으로는 불가.
    
    다중스레드로도 처리하기에는 스레드 전환 등 부담
    
    커널이 상태를 확인하는 대신 커널에게 입출력 준비완료 알림을 보내는 입출력 다중화!
    

### 입출력 다중화

- 과정
    1. 파일 서술자 획득
    2. 커널에게 파일 서술자가 입출력 가능한 상태일 때 알림을 보내달라고 함
    3. 커널이 알림을 보내오면 입출력 처리
- 동기 입출력 다중화
    1. select, poll : 입출력 준비 완료 시 알림을 보냄. 그러나 어떤 프로세스가 알림을 보낸건지 모든 프로세스를 확인해야해서 비효율적
    2. epoll : 입출력 준비 완료 알림을 보낼 때 준비완료 대기열에 해당 프로세스를 추가함. 준비완료 대기열만 확인하면 완료된 파일서술자를 찾을 수 있음. 효율적!
        
        → 리눅스에서 높은 동시성에 사용됨
        
- 비동기 입출력 다중화
    - mmap : 파일을 **메모리처럼** 읽고 쓰면 다루기가 쉬움
        
        → **가상메모리**로 파일이 메모리(프로세스 주소공간)에 적재된 것처럼 사용!
        
        메모리라서 파일의 주소단위가 아닌 메모리처럼 바이트단위로 접근 가능
        
        - 페이지 누락page fault : 접근하려는 파일 위치가 메모리 주소공간에 맵핑되기 전인 경우 발생
            
            누락 시 디스크에서 읽고 쓰는 작업은 OS가 진행. 프로세스는 신경x
            
        - 파일을 읽고쓰기위해 복사하는 번거로움이 없음
        - 맵핑(사상) 관계를 저장하기 위한 데이터 구조 유지 필요
        - 성능 면에서 항상 좋다고 할 수는 없음. 테스트를 통해 판단할 것
    - mmap 의 큰 파일 처리 : 파일 용량이 물리 메모리 용량을 초과할 경우
        - 가상메모리를 통해 큰 파일도 주소만 메모리에 (프로세스 주소공간에) 사상 가능. 실제 용량은 상관없음
        - 큰 파일 처리와 파일의 임의위치를 접근할 때 코드 설계 단순화 (read()등의 동기 입출력은 파일이 더 크면 부분적으로 메모리에 올려 처리해야 함)
        - 옵션
            - MAP_SHARED : 디스크에 읽고 씀
            - MAP_PRIVATE : 실제로 메모리를 할당함. 파일크기가 물리메모리+swap 영역을 초괗하면 메모리 부족 오류 발생
    - mmap 은 읽기 전용 방식으로 동일한 데이터를 참조하는 경우 매우 유용
        - e.g. 동적 링크 라이브러리 : 실제 코드는 한곳에만 존재, 사용하는 프로세스들에서 가상메모리로 사상해서 사용
