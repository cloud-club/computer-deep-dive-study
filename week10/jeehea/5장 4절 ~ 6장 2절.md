

### 질문
- (417p)
  ```
  무엇보다 흥미로운 점은 그림 5-44에서 모든 유형의 CPU가 StoreLoad 재정렬을 가지고 있다는 것입니다.  
  필자 역시 추측에 불과하지만, 우리는 프로그래밍을 할 때 StoreLoad 같은 순서의 일관성을 거의 사용하지 않을 것입니다.
  ```
    → 이게 무슨 말인가요…   
    StoreLoad 가 저장 전에 읽기조차 금지한다는 점에서 배타락이랑 비슷한 거 아닌가요? 그거랑 다른 맥략의 말인가요..?
- (444p)  
  DMA 가 메모리 데이터 접근 시  
    캐시와 실제메모리 간 데이터 값 차이가 날 때 대응 방안 = 즉시 갱신 밖에 없다는 건가요?
  

### 메모리 장벽

- CPU 의 **비순차적 명령어 처리 (OoOE**, Out of Order Execution)
    - CPU 마다 다르지만, 성능을 위해 반드시 프로그래머가 작성한 순서대로 코드를 실행하지는 않음
    - 명령어 순서를 유지한다 해도,
        
        코어가 여러개일 경우 다중 스레드 실행과 캐시 지연 갱신 문제 존재
        
    - 이 때,
        
        잠금없는 프로그래밍을 사용하고 있다면
        
        이로 인해 코드 실행 결과가 의도와 다를 수 있음
        
    - 잠금없는 프로그래밍을 사용하지 않는다면 이 문제를 고려할 필요가 없음
- 메모리 장벽
    - CPU 에 의해 코드의 실행순서가 보장되지 않는 것을 방지
    - 데이터 저장, 로드 코드의 실행 순서를 보장하는 4가지 유형 존재
- 메모리 장벽 유형
    - LoadLoad, LoadStore : 앞의 Load 가 완료된 후에 뒷명령 실행
    - StoreStore, StoreLoad : 앞의 Store 가 완료된 후에 뒷명령 실행
        - StoreLoad 는 동기 작업과 유사한 것
- 획득 - 해제 의미론 (store-release)
    - 획득 의미론 : Load 실행 전에 다른 작업이 실행될 수 없음. (LoadLoad + LoadStore)
    - 해제 의미론 : Store 실행 후에 다른 작업이 실행될 수 없음 (StoreStore + StoreLoad)
- CPU 제품
    - 약한 메모리 모델 : 거의 모든 유형의 명령어 재정렬 기능존재
    - 강한 메모리 모델 : 재정렬 기능 거의 없음 e.g. x86
- 잠금 프로그래밍 : 상호배제, 스핀잠금 등을 활용해서 락을 사용

### 입출력

- 비동기 인터럽트를 통해 처리
- 인터럽트 처리 스택은 커널에 있어야함
    - CPU가 커널 상태일 때에만 접근 가능. 일반 프로그램은 접근 불가
- 디스크가 인터럽트 처리하는 동안 CPU는 다른 수행 → 효율
- 장치 제어기 : 장치 하드웨어에서 장치 드라이버가 명령한 작업 수행. CPU 의 일 줄여줌
- 직접 메모리 접근 DMA : 메모리에서 장치로 데이터를 이동 저장 시키는 작업을 담당. CPU 없이도 메모리 접근 가능, CPU를 더 효율적으로 운영하게 함

- (그 외 인터럽트 처리 과정 내용들 간단하게 ..)
