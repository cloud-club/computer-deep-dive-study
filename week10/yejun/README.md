## 봉화희제후와 메모리 장벽
___

스레드 사이 동기화?

명령어의 순서에 따라 결과가 달라질 수 있음

<img width="475" alt="스크린샷 2025-05-21 오후 4 38 11" src="https://github.com/user-attachments/assets/d4efd1b8-f08f-4453-a615-769f951a4dcb" />

의도한 대로 동작한다면 문제없이 봉화대 점화 사실을 발견할 수 있으나 컴퓨터 명령어상 비순차적 실행 특성에 의해 봉화대 점화 되기 직전 봉화 확인이 실행될 수 있음

이를 `비순차적 명령어 실행: OoOE(Out of Order Execution)`이라고 하며, CPU 설계에서는 성능 향상을 위해, 명령어가 항상 순서대로 실행되지 않기도 함
___

`비순차적 명령어 실행 OoOE(Out of Order Execution)` 발생 경우

- 컴파일러가 최적화를 위해 명령어 순서를 변경하는 것
- 명령어 실행 시 CPU가 명령어 파이프 라인의 빈공간(slot)을 메우기 위해 명령어 실행 순서를 변경하는 것
  - 명령어가 의존하는 피연산자를 기다리는 동안(예를 들어 메모리에서 레지스터로 가져오기) 파이프 라인이 비어있을 수 있음. 이 공간을 이미 준비 완료된 명령어로 먼저 채우는 것.
- 캐시 일관성 문제 때문에 어떤 코어의 명령어가 다른 코어에서 봤을 때 순서대로 실행되어 보이지 않을 수 있음
  - CPU와 캐시 사이에 store buffer 가 존재하도록 설계하며 캐시에 업데이트하는 것을 CPU가 결정할 수 있음
  - 자신 외의 코어가 공유하고 있는 데이터일 경우 순서가 보장되지 않을 수 있음 => lock이 필요

CPU 설계는 허술하지 않기 때문에, 당연히 명령어가 실행되는 해당 스레드 내부에서는 이런 비순차적 실행이 보이지 않는다

**하지만 자신 이외에 또 다른 스레드(코어)가 자신과 공유하고 있는 데이터에 접근할 때는, 이 비순차적 실행 과정이 드러날 수 있다**

물론, lock 을 획득하여 동기화를 하면 문제 없다. 다만 `lock-free programming`을 시도할 때가 문제가 된다.

lock-free programming 이란 다중 스레드의 공유 리소스 사용 시 실제로는 lock 없이도 처리가 가능하기 때문에 특정 원리(e.g. CAS(Compare And Swap)원자성 작업)를 활용해서 lock 사용을 회피하는 것이다.

(단 원자성 작업에는 ABA 문제가 존재할 수 있음)

이렇게 lock 이 없는 상황에서 OoOE 문제를 해결하기 위해 사용하는 것이 바로 메모리 장벽, 즉 memory barrier 이다.

___

memory barrier 는 구체적인 기계 명령어를 의미하는 것으로, 4가지가 있다.

메모리 관련 작업에는 LOAD 와 STORE 가 있는데, 각 memory barrier 이름에 명시된 **명령어의 순서를 해치지 말라고 명시해두는 기계 명령어**이다.

1. LOADLOAD

<img width="563" alt="스크린샷 2025-05-21 오후 5 04 11" src="https://github.com/user-attachments/assets/8fabf478-2cfd-432f-a363-02ed47fe4ae2" />

Load Load하는 상황에서 순서를 넘어버리면 n은 여전히 0일 수 있음

2. STORESTORE

<img width="643" alt="스크린샷 2025-05-21 오후 5 05 42" src="https://github.com/user-attachments/assets/8060b3c5-0d85-4f86-a90f-14adc5e3f449" />

Store Store하는 상황에서 순서를 넘어버리면 n은 여전히 0일 수 있음

3. LOADSTORE

비교적 오래 걸리는 STORE가 LOAD보다 먼저 실행될 경우가 있을까 싶지만, 캐시 미스 시에 가능하다고 한다.

4. STORELOAD

네 가지 memory barrier 중 가장 '무겁다'. 문자 그대로 "이 memory barrier 이전에 존재하는 쓰기가 완료되기 전까지 memory barrier 이후의 읽기를 하지 못한다"는 의미이기 때문이다.
___

이러한 memory barrier 들은 LOAD와 STORE 명령어를 특정해 순서를 보장하고 있어서, 각 memory barrier를 `조합`해 사용해야 할 경우가 많다.

LOAD 명령어 뒤에 있는 LOAD 와 STORE 명령어의 비순차적 실행을 방지하기 위해선 LOADLOAD 와 LOADSTORE 를 동시에 사용해야 함

-> 이를 해소하기 위해 "acquire-release semantics" 를 사용

memory barrier의 조합.

- acquire
  - 읽기 작업 관련 (LOAD)
  - barrier에 해당하는 LOAD 명령어 이후에 있는 모든 메모리 명령어가 barrier 이전으로 재정렬 되지 않도록.
  - `LOADSTORE` + `LOADLOAD` 조합.

해당 명령어 LOAD가 완료되고 난 후 실행해야 하는 모든 메모리 작업

- release
  - 쓰기 작업 관련 (STORE)
  - barrier에 해당하는 STORE 명령어 이전에 있는 모든 메모리 명령어가 barrier 이후로 재정렬 되지 않도록.
  - `LOADSTORE` + `STORESTORE` 조합.

해당 명령어 STORE를 완료하기 전 실행해야 하는 모든 메모리 작업

<img width="643" alt="스크린샷 2025-05-21 오후 5 24 46" src="https://github.com/user-attachments/assets/42160333-8bca-4ccb-ad97-c5ae558258ae" />

___

CPU 별로 발생 가능한 재정렬의 종류가 천차만별이기 때문에 프로그램 언어 수준에서 제공하는 acquire-release semantics 인터페이스가 존재 -> C++의 atomic 원자 라이브러리에서 제공

모든 유형의 명령어 재정렬이 가능한 CPU 플랫폼을 **약한 메모리 모델(weak memory model)**

자체적으로 acquire-release semantics 을 내재하고 있는 플랫폼을 **강한 메모리 모델(strong memory model)**-> x86은 STORELOAD 재정렬 제공

결국 이러한 memory barrier 는
`lock 없이 리소스를 공유하는 다중 스레드` 환경에서 필요한 기술.

그렇다면 대체 왜 lock 없이 멀티 스레드 리소스 공유를 하는가?

lock은 아주 좋은 공유 리소스 관리 도구이다

mutual exclusion 혹은 spin lock 이 있으며 lock을 사용하면 lock을 얻지 못한/얻고자 하는 스레드가 블로킹 됨

lock-free 는 바로 이 블로킹 없이 스레드가 항상 어떤 일을 하도록 하는 것에 가치를 두며 성능 향상이 목적이 아니고 구현도 매우 까다로움

___

### CPU는 어떻게 입출력 작업을 처리할까?

입출력 장치(device)는 레지스터로 구성되어 있어, **CPU가 이 레지스터를 참조해 입출력 작업을 처리**

즉, CPU의 입장에서 장치는 다음과 같은 종류의 저수준 계층 레지스터를 한데 묶어놓은 것에 불과하다.

1. 데이터를 저장하는 레지스터
   - 장치가 입력받은 데이터가 저장되어 있는곳
2. 제어정보 / 상태정보를 저장하는 레지스터
   - CPU가 이 레지스터를 읽고 쓰며 장치 제어, 상태확인이 가능한 곳

레지스터를 읽고 쓰는 방법은 다름 아니라 기계 명령어

1. 입출력 기계 명령어
   - 입출력 장치의 레지스터에 접근하기 위한 특정한 기계 명령어 (e.g. x86의 IN, OUT)
   - 장치마다 고유한 주소를 부여해서 접근할 수 있도록 한다.
2. 메모리 사상 입출력
   - 메모리 주소 공간의 일부분을 장치에 할당해서, LOAD / STORE 명령어로 장치 레지스터에 접근할 수 있도록 한다.

CPU에 접근하는 시점?

1. 폴링(polling) : 장치 상태 레지스터를 지속적으로 검사해서 처리할 데이터가 있는지 확인. 동기적
2. 인터럽트 구동식 : 장치가 보내는 인터럽트 신호가 발생했을 때만 데이터를 처리하는 것. 비동기적
   - 하드웨어의 인터럽트 감지를 위해, CPU 명령어 실행 단계 (IF, ID, EX, WB) 에 인터럽트 신호를 감지하는 단계가 추가되어야 한다.
   - 인터럽트 발생 시
     1. 현재 context 를 커널 스택에 저장
     2. 현재 실행 중인 작업과 인터럽트 처리의 우선순위를 비교
     3. 인터럽트 처리가 우선되어야 한다면 인터럽트를 처리
     4. 저장해두었던 context를 복구해 실행흐름을 재개

___

### 디스크가 입출력을 처리할 때 CPU가 하는 일은 무엇일까?

결과 처리 제외, 디스크 입출력과 CPU의 활동(다른 스레드 실행, 커널 작업, 유휴 상태)는 병행 가능 (입출력 처리 시 CPU가 하는 일은 없음)

- 장치 제어기 (device controller)

디스크에서 물리적 기계 장치(헤드, 실린더, 섹터, )를 제외한 전자 장치 부분을 장치 제어기라고 부른다.

최신 컴퓨터 시스템에서 장치 제어기는 별도의 프로세서와 펌웨어, 특히 자신만의 버퍼와 레지스터를 갖는 하나의 마이크로 컴퓨터 시스템이다.

따라서 CPU의 개입 없이 디스크에서 요청받은 데이터를 읽어오거나 쓸 수 있다.

(메모리에 접근하는 것은 아님. 디스크 내부에서 데이터를 준비해오거나 저장하는 역할)

<img width="675" alt="스크린샷 2025-05-21 오후 5 58 07" src="https://github.com/user-attachments/assets/126575a4-4230-4e2b-bccd-35a77b98a71d" />

`장치 드라이버`와는 다른 개념. 드라이버는 OS가 관리하는 소프트웨어이고, 장치 제어기는 실제 하드디스크와 드라이버를 연결하는 다리 정도의 개념.
____

- 직접 메모리 접근 (direct memory access)

장치 제어기가 준비한 데이터를 메모리에 올리거나, 메모리의 데이터를 저장하기 위해 장치 제어기에게 전달하는 과정 또한 CPU가 직접 하지 않는다.

<img width="572" alt="스크린샷 2025-05-21 오후 5 56 58" src="https://github.com/user-attachments/assets/2a5b7d3e-6c81-41bf-9c20-bb3406eec558" />

DMA(Direct Memory Access)는 일반적으로 입출력 장치와 메모리 사이에 데이터를 전송하는 주체.

CPU가 데이터 전송을 직접하지 않고 DMA에게 명령하여 대신 수행하게 한다.

폴링과 인터럽트에 이어서 메모리와 장치 사이에 데이터를 전송하는 방법 중 하나이다.

이 과정에서 `가상 메모리 문제`와 `캐시 일관성 문제`가 발생할 수 있는데,

가상 메모리 문제는 DMA를 위해 메모리 사상 정보를 CPU가 제공하면 해결할 수 있다.

캐시 문제는 동기적인 write-through 방식으로 해결할 수 있다.
____

- 인터럽트

입출력 과정이 완료된 결과를 가지고 처리(handle)해야 하는 시점은 인터럽트 로 CPU에게 전달된다.

DMA가 데이터 전송을 완료하면 인터럽트를 발생시켜 CPU에게 입출력 작업이 완료되었음을 알리고

CPU는 실행 중인 스레드를 일시 정지한 후 입출력 작업을 위해 블로킹 되었던 스레드의 실행을 재개한다.
