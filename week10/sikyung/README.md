## 5장 작은 것으로 큰 성과 이루기, 캐시

### 5.4. 봉화히제후와 메모리 장벽

### 명령어의 비순차적 실행과 캐시, 멀티코어

1. 명령어는 작성 순서대로 실행되지 않음

   - CPU는 프로그램 코드를 작성된 순서 그대로 실행하지 않음
   - 이유: 더 빠르게 실행하려고 컴파일러가 명령어를 재배치하거나 CPU가 순서를 바꿔 실행함 (→ Out of Order Execution, OoOE)

2. 예시로 설명: a = b + 100; b = 200;

   - 이 코드는 작성 순서는 a를 먼저 계산하고 b를 설정하지만
   - CPU는 b = 200을 먼저 실행해도 문제가 없기 때문에 순서를 바꿔 실행할 수 있음

3. 명령어 재정렬이 문제를 일으키는 경우

   - 단일 스레드 안에서는 재정렬이 있어도 결과는 같음
   - 하지만 여러 스레드가 동시에 같은 데이터를 사용할 땐, 이 재정렬이 **문제**를 만듦
   - 한 스레드는 변수 a를 설정 중인데 다른 스레드는 그걸 보고 이미 설정되었다고 착각할 수 있음

4. 저장 버퍼와 캐시의 역할

   - CPU는 어떤 값을 메모리에 ‘기록하겠다’고 하면, 실제로는 저장 버퍼에 먼저 기록함
   - 이 값은 아직 캐시나 메모리에 들어가지 않았지만, CPU는 이미 설정된 것처럼 행동함
   - 다른 CPU 코어는 이 값을 아직 볼 수 없으므로 **혼선 발생 가능**

5. 이로 인해 생기는 문제: 실행 순서가 꼬인다

   - A 코어는 `a = 1` 하고 나서 `b = y`를 실행
   - 그런데 이 a = 1이 아직 캐시에도 안 들어갔는데, B 코어가 b 값을 읽어 가버리면 a 값이 0일 수도 있음
   - 결과적으로 b = y가 먼저 실행된 것처럼 보임 → 순서가 꼬인 듯한 현상 발생

6. 해결책: 메모리 장벽 (Memory Barrier)

   - CPU에게 “이 명령어들 순서 꼭 지켜!”라고 강제로 말하는 명령어
   - 이를 이용하면 재정렬을 막고, **순서 보장**이 가능해짐

### 잠금과 잠금 없는 프로그래밍

1. 잠금(lock)은 공유 데이터를 보호하는 방법

   - 여러 스레드가 동시에 데이터를 바꾸면 꼬일 수 있으니, 먼저 차지한 스레드가 작업을 끝낼 때까지 막아 둠
   - 대표적 방법: mutex, spinlock

2. 잠금 없는 프로그래밍 (lock-free)

   - 공유 데이터에 접근할 때 **굳이 차례 기다릴 필요가 없도록** 만든 프로그래밍 기법
   - 핵심: 한 스레드는 언제든 작업을 계속할 수 있어야 함
   - 사용 예: compare-and-swap(CAS) 알고리즘

3. 잠금 없는 환경에서는 재정렬이 더 민감한 문제

   - 공유 변수의 상태를 여러 스레드가 동시에 확인하기 때문에,
   - 한쪽이 변수 값을 설정했는지 안 했는지 정확히 알아야 함
   - 재정렬이 발생하면, 아직 설정도 안 된 데이터를 읽는 사고 발생 가능

4. 해결책: 메모리 장벽 사용

   - 명령어는 재정렬되더라도, **메모리 접근 순서만은 강제 정렬**해주는 장치
   - Load-Load, Store-Store 등 다양한 장벽이 존재함

### 요약

1. CPU는 코드를 순서대로 실행하지 않음 (성능을 위해 순서 재배치함)
2. 단일 스레드에서는 문제 안 생김
3. 멀티 스레드에서는 이 재정렬이 **심각한 버그**로 이어질 수 있음
4. 이걸 막기 위해선 **메모리 장벽**이 필요함
5. **잠금 없는 프로그래밍**을 할 땐 반드시 이 점을 인지하고 코딩해야 함
